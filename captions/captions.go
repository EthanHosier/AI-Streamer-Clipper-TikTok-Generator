package captions

import (
	"encoding/json"
	"encoding/xml"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
)

type CaptionsHandler interface {
	CaptionsFromXml(filepath string, typ CaptionsType)
}

type CaptionsClient struct {
}

func NewCaptionsClient() *CaptionsClient {
	return &CaptionsClient{}
}

func (c *CaptionsClient) CaptionsFromJson(filepath string, typ CaptionsType) {
	if typ != CaptionsASS {
		fmt.Println("Unsupported captions type")
		return
	}

	jsonFile, err := os.Open(filepath)
	if err != nil {
		fmt.Println("Error opening file:", err)
		return
	}

	byteValue, _ := ioutil.ReadAll(jsonFile)

	var captions Captions
	err = json.Unmarshal(byteValue, &captions)
	if err != nil {
		fmt.Println("Error unmarshalling JSON:", err)
		return
	}

	fmt.Printf("Captions: %+v\n", captions.Events)
	assFile, err := os.Create("output.ass")
	if err != nil {
		fmt.Println("Error creating ASS file:", err)
	}
	defer assFile.Close()

	header := `[Script Info]
; Script generated by XML to ASS converter
Title: Converted Subtitles
ScriptType: v4.00+
Collisions: Normal
PlayDepth: 0

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,24,&H00FFFFFF,&H00FFFF00,&H00000000,&H64000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`
	assFile.WriteString(header)

	for i, event := range captions.Events {
		if event.Segs == nil || len(event.Segs) == 1 && event.Segs[0].UTF8 == "\n" {
			continue
		}

		endTime := event.TStartMs + event.DDurationMs

		if i < len(captions.Events)-1 {
			endTime = captions.Events[i+1].TStartMs - event.TStartMs - 1
		}

		dialogue := fmt.Sprintf("Dialogue: 0,%s,%s,Default,,0,0,0,,", msToASSTime(event.TStartMs), msToASSTime(endTime))
		for i, s := range event.Segs {
			fmt.Print(s.UTF8)

			if i == len(event.Segs)-1 {
				wordDuration := endTime / 10
				dialogue += fmt.Sprintf("{\\k%d}%s ", wordDuration, strings.TrimSpace(s.UTF8))
			} else {
				wordDuration := (event.Segs[i+1].TOffsetMs - s.TOffsetMs) / 10
				dialogue += fmt.Sprintf("{\\k%d}%s ", wordDuration, strings.TrimSpace(s.UTF8))
			}
		}

		assFile.WriteString(dialogue + "\n")
	}
}

func (c *CaptionsClient) CaptionsFromXml(filepath string, typ CaptionsType) {
	if typ != CaptionsASS {
		fmt.Println("Unsupported captions type")
		return
	}

	xmlFile, err := os.Open(filepath)
	if err != nil {
		fmt.Println("Error opening file:", err)
		return
	}
	defer xmlFile.Close()

	byteValue, _ := ioutil.ReadAll(xmlFile)

	var timedText TimedText
	xml.Unmarshal(byteValue, &timedText)

	assFile, err := os.Create("output.ass")
	if err != nil {
		fmt.Println("Error creating ASS file:", err)
	}
	defer assFile.Close()

	header := `[Script Info]
; Script generated by XML to ASS converter
Title: Converted Subtitles
ScriptType: v4.00+
Collisions: Normal
PlayDepth: 0

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,24,&H00FFFFFF,&H000000FF,&H00000000,&H64000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`

	assFile.WriteString(header)

	counter := 1
	for _, p := range timedText.Body.P {
		startTime := msToASSTime(p.T)
		endTime := msToASSTime(p.T + p.D)

		// Build the dialogue line with individual word timings
		dialogue := fmt.Sprintf("Dialogue: 0,%s,%s,Default,,0,0,0,,", startTime, endTime)
		for _, s := range p.S {
			// Calculate the word timing in centiseconds
			wordDuration := 100
			if s.T > 0 {
				wordDuration = s.T / 10
			}
			dialogue += fmt.Sprintf("{\\k%d}%s ", wordDuration, s.Text)
		}

		// Write dialogue line to ASS file
		assFile.WriteString(dialogue + "\n")
		counter++
	}

	fmt.Println("Conversion completed successfully. Output written to output.ass")
}

func msToASSTime(ms int) string {
	h := ms / 3600000
	m := (ms % 3600000) / 60000
	s := (ms % 60000) / 1000
	cs := (ms % 1000) / 10
	return fmt.Sprintf("%d:%02d:%02d.%02d", h, m, s, cs)
}
