package captions

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
)

type CaptionsHandler interface {
	CaptionsFromXml(filepath string, typ CaptionsType)
}

type CaptionsClient struct {
}

func NewCaptionsClient() *CaptionsClient {
	return &CaptionsClient{}
}

func (c *CaptionsClient) CaptionsFrom(url string, typ CaptionsType) (string, error) {
	if typ != CaptionsASS {
		return "", fmt.Errorf("unsupported captions type")
	}

	// Fetch the captions file from the URL
	resp, err := http.Get(url)
	if err != nil {
		return "", fmt.Errorf("error fetching URL: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("received non-200 response code: %d", resp.StatusCode)
	}

	// Read the content into memory
	byteValue, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("error reading response body: %v", err)
	}

	var captions Captions
	err = json.Unmarshal(byteValue, &captions)
	if err != nil {
		return "", fmt.Errorf("error unmarshalling JSON: %v", err)
	}

	header := `[Script Info]
; Script generated by XML to ASS converter
Title: Converted Subtitles
ScriptType: v4.00+
Collisions: Normal
PlayDepth: 0

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,24,&H00FFFFFF,&H00FFFF00,&H00000000,&H64000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`

	ret := ""

	for i, event := range captions.Events {
		if event.Segs == nil || len(event.Segs) == 1 && event.Segs[0].UTF8 == "\n" {
			continue
		}

		endTime := event.TStartMs + event.DDurationMs

		if i < len(captions.Events)-1 {
			endTime = captions.Events[i+1].TStartMs - event.TStartMs - 1
		}

		dialogue := fmt.Sprintf("Dialogue: 0,%s,%s,Default,,0,0,0,,", msToASSTime(event.TStartMs), msToASSTime(endTime))
		for i, s := range event.Segs {
			if i == len(event.Segs)-1 {
				wordDuration := endTime / 10
				dialogue += fmt.Sprintf("{\\k%d}%s ", wordDuration, strings.TrimSpace(s.UTF8))
			} else {
				wordDuration := (event.Segs[i+1].TOffsetMs - s.TOffsetMs) / 10
				dialogue += fmt.Sprintf("{\\k%d}%s ", wordDuration, strings.TrimSpace(s.UTF8))
			}
		}

		ret += dialogue + "\n"
	}

	return header + "\n" + ret, nil
}

func msToASSTime(ms int) string {
	h := ms / 3600000
	m := (ms % 3600000) / 60000
	s := (ms % 60000) / 1000
	cs := (ms % 1000) / 10
	return fmt.Sprintf("%d:%02d:%02d.%02d", h, m, s, cs)
}
